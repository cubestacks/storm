/**
 *
 */
package in.cubestack.android.lib.storm.core;

import java.lang.reflect.Field;

import in.cubestack.android.lib.storm.FieldType;
import in.cubestack.android.lib.storm.annotation.Column;
import in.cubestack.android.lib.storm.annotation.Database;
import in.cubestack.android.lib.storm.annotation.LifeCycle;
import in.cubestack.android.lib.storm.annotation.PrimaryKey;
import in.cubestack.android.lib.storm.annotation.Relation;
import in.cubestack.android.lib.storm.annotation.Table;
import in.cubestack.android.lib.storm.lifecycle.LifeCycleHandler;
import in.cubestack.android.lib.storm.util.Reflections;

/**
 * A core Android SQLite ORM framework build for speed and raw execution.
 * Copyright (c) 2011 Supal Dubey, supal.dubey@gmail.com
 * <p/>
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * <p/>
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * <p/>
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
public class MetaDataReader {

	private static final String EMPTY_STRING = "";
	private FieldTypeResolver fieldTypeResolver = new FieldTypeResolver();
	private TableInformation tableInformation = new TableInformation();
	private QueryGenerator queryGenerator = new QueryGenerator();

	// Alias must be specific to a mapped Entity

	public TableInformation readAnnotations(Class<?> annotation, AliasGenerator aliasGenerator)
			throws IllegalArgumentException, IllegalAccessException, InstantiationException, StormException {

		runValidations(annotation);

		Table table = (Table) annotation.getAnnotation(Table.class);
		String tableStrName  = table.name();
		
		tableInformation.setMappedClass(annotation);
		tableInformation.setTableName(tableStrName);
		tableInformation.setTableVersion(table.version());
		tableInformation.setAlias(aliasGenerator.generateAlias(annotation));

		if (annotation.isAnnotationPresent(LifeCycle.class)) {
			Class<?> handlerClass = annotation.getAnnotation(LifeCycle.class).handler();
			Object handler = handlerClass.newInstance();
			tableInformation.setHandler((LifeCycleHandler<?>) handler);
		}

		readTableFields(annotation, aliasGenerator);
		generateCreate();
		return tableInformation;
	}

	private void runValidations(Class<?> annotation) throws StormException {
		if (annotation.getAnnotation(Table.class) == null) {
			throw new StormException(String.format(
					"Please map the class %s with @Table annotation or remove it from @Database declarations.",
					annotation.getName()));
		}
		Table table = (Table) annotation.getAnnotation(Table.class);
		if(table.name() == null || EMPTY_STRING.equals(table.name())) {
			throw new StormException(String.format("Please provide table name in %s class, with @Table Annoataion name", annotation.getName() ));
		}
	}

	private void readTableFields(Class<?> annotation, AliasGenerator aliasGenerator)
			throws IllegalArgumentException, IllegalAccessException, StormException {
		Class<?> clazz = annotation;
		while (clazz.getSuperclass() != null) {
			for (Field field : clazz.getDeclaredFields()) {
				if (field.isAnnotationPresent(Column.class)) {
					if (field.isAnnotationPresent(PrimaryKey.class)) {
						tableInformation.setPrimaryKeyData(getColumnMetaData(field));
						tableInformation.setAutoGenerated(field.getAnnotation(PrimaryKey.class).autoGenrateKey());
					} else {
						tableInformation.getColumnMetaDataList().add(getColumnMetaData(field));
					}
				} else if (field.isAnnotationPresent(Relation.class)) {
					RelationMetaData relationMetaData = new RelationMetaDataReader().fetchRelationMetaData(field,
							field.getAnnotation(Relation.class), aliasGenerator);
					tableInformation.getRelations().add(relationMetaData);
					
					validate(tableInformation,relationMetaData );				}
			}
			clazz = clazz.getSuperclass();
		}

		// Validate we have a primary key
		if (tableInformation.getPrimaryKeyData() == null) {
			throw new StormException(String.format(
					"Please update entity %s, to contain atleast one column as Primary Key using @PrimaryKey annotation. Also make sure Primary Key has @Column Annotation",
					annotation.getName()));
		}
	}

	private void validate(TableInformation tableInfo, RelationMetaData relationMetaData) throws StormException {
		
		if(EMPTY_STRING.equals(relationMetaData.getJoinColumn())) {
			throw new StormRuntimeException(String.format("Join column details missing in @Relation for class %s, mapped for parent class %s ",
					relationMetaData.getTargetEntity(), tableInfo.getMappedClass()));
		}
		try {
			String joinColumn = relationMetaData.getJoinColumn();	
			if(! Reflections.isValidField(relationMetaData.getTargetEntity(), joinColumn)) {
				throw new StormException(String.format("Unable to find field with name %s as join column for @Relation for class %s, mapped for parent class %s ",
						joinColumn, relationMetaData.getTargetEntity(), tableInfo.getMappedClass()));
			}
			
		} catch (Exception exception) {
			throw new StormException(String.format("Please check the mapping for @Relation for class %s, mapped for parent class %s", relationMetaData.getTargetEntity(), 
					tableInfo.getMappedClass()), exception);
		}

	}

	private void generateCreate() throws IllegalArgumentException, IllegalAccessException, InstantiationException {
		tableInformation.setInsertSql(queryGenerator.insertQuery(tableInformation, tableInformation.isAutoGenerated()));
	}

	public DatabaseMetaData fetchDatabaseMetaData(Class<?> databaseClass) {
		Database database = databaseClass.getAnnotation(Database.class);
		DatabaseMetaData metaData = new DatabaseMetaData();
		metaData.setVersion(database.version());
		metaData.setName(database.name());
		metaData.setTables(database.tables());
		metaData.setHandler(database.handler());
		return metaData;
	}

	private ColumnMetaData getColumnMetaData(Field field) throws IllegalArgumentException, IllegalAccessException {
		ColumnMetaData columnMetaData = new ColumnMetaData();
		Column column = field.getAnnotation(Column.class);
		String alias = field.getName();
		String columnName = column.name();
		boolean parentReferenceKey = column.parentReferenceKey();
		columnMetaData.setParentReferenceKey(parentReferenceKey);
		columnMetaData.setAlias(alias);
		columnMetaData.setColumnName(columnName);
		FieldType fieldType = column.type();
		columnMetaData.setFiledTypes(fieldTypeResolver.fetchMatching(field, fieldType));
		columnMetaData.setAddedVersion(column.addedVersion());
		return columnMetaData;
	}
}
